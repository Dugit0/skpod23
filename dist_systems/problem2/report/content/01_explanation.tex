\section{Сделанные модификации алгоритма}
Были произведены следующие модификации алгоритма:
\begin{enumerate}
    \item После каждой итерации релаксации добавлены контрольные точки. Каждый
        процесс сохраняет кубы, с которыми он работает в отдельный файл
        с названием \code{<номер процесса>.mpi}.
    \item Установлена функция-errorhandler. При поломке процесса и попытке
        взаимодействовать с ним управление передается в нее. После этого сразу
        вызываются функции \code{MPIX\_Comm\_revoke} и \code{MPIX\_Comm\_shrink}.
        Первая отменяет все пересылки на коммуникаторе, а вторая изменяет
        номера процессов так, чтобы устранить пробел в нумерации процессов.
        После необходимо отменить все, что было вычисленно в последней итерации,
        которая не дошла до конца, чтобы синхронизировать данные всех процессов.
        На языке C пришлось бы использовать множественное \code{goto}, однако
        в языке C++ существует механизм исключений, который очень удобно использовать
        для этих целей.
    \item После вызова функции-errorhandler'а управление будет передано в
        catch-блок, в котором
        \begin{enumerate}
            \item Будет произведена очистка кубов, которые использовались
                процессом ранее, чтобы избежать утечек памяти.
            \item Счетчик итераций будет уменьшен на 1, чтобы откатить
                последнюю итерацию.
            \item Будет загружена контрольная точка, соответствующая новому
                номеру процесса.
        \end{enumerate}
\end{enumerate}

\section{Временная оценка}
Основное отличие от алгоритма, реализованного в курсе <<Суперкомпьютеры и
параллельная обработка данных>>, заключается в создании и поддержке контрольных
точек. Заметим, что по сути на каждой итерации алгоритма мы сохраняем всю
вычисленную матрицу. Разумеется это очень сильно замедляет программу. Таким
образом можно заключить, что такая стратегия контрольных точек будет эффективна
в следующих случаях:
\begin{enumerate}
    \item Одна итерация является достаточно <<дорогой>> (по времени или
        вычислительным ресурсам) и нам действительно важно сохранять прогресс
        после каждой итерации.
    \item Запись контрольной точки является относительно <<дешевой операцией>>
        и не будет сильно увеличивать время работы программы.
\end{enumerate}
